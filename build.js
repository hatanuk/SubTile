// To use SubTile, copy the minified code below into your Sprig file.
// Refer to https://github.com/hatanuk/SubTile for usage details 
 
class SubTileRenderer{constructor(screenTileWidth=10,screenTileHeight=8){this.TILESIZE=16,this.screenTileHeight=screenTileHeight,this.screenTileWidth=screenTileWidth,this.pixelHeight=this.screenTileHeight*this.TILESIZE,this.pixelWidth=this.screenTileWidth*this.TILESIZE,this.dirtyBucket=new Set,this.surfaces=[],this.buffer=new Buffer(this.screenTileWidth*this.TILESIZE,this.screenTileHeight*this.TILESIZE),this.tileBitmap=this._createTileBitmap(),this.legend=this._createLegend(),setLegend(...this.legend),setMap(this.tileBitmap)}beginFrame(){this.clearDirtyBucket()}endFrame(){this.surfaces.forEach(surface=>this._drawSurface(surface));for(const index of this.dirtyBucket){const{tx:tx,ty:ty}=this._legendIndexToTile(index);this.legend[index][1]=this._tileToBitmap(tx,ty)}setLegend(...this.legend)}clearSurface(surface){surface.buffer.clear(),this._drawSurface(surface,!0)}clearAll(){this.buffer.clear(),this.markAllDirty()}markDirty({tx:tx,ty:ty}){tx<0||ty<0||tx>=this.screenTileWidth||ty>=this.screenTileHeight||this.dirtyBucket.add(this._getLegendIndex(tx,ty))}markAllDirty(){for(let ty=0;ty<this.screenTileHeight;ty++)for(let tx=0;tx<this.screenTileWidth;tx++)this.markDirty({tx:tx,ty:ty})}clearDirtyBucket(){this.dirtyBucket.clear()}isDirty({tx:tx,ty:ty}){return this.dirtyBucket.has(this._getLegendIndex(tx,ty))}addSurface(surface,x=0,y=0){surface.T.b0=x,surface.T.b1=y,this.surfaces.includes(surface)?(this.removeSurface(surface),this.addSurface(surface,x,y)):this.surfaces.push(surface)}removeSurface(surface){this.surfaces=this.surfaces.filter(currentSurface=>currentSurface!==surface)}applyTransformation(surface,{scaleX:scaleX=1,scaleY:scaleY=1,xOffset:xOffset,yOffset:yOffset}={}){xOffset=xOffset??surface.T.b0,yOffset=yOffset??surface.T.b1,surface.applyTransformation(new Transform2D(scaleX,0,0,scaleY,xOffset,yOffset))}removeTransformations(surface){surface.resetTransformations()}_drawSurface(surface,clearing=!1){if(surface.isTransformed())surface.getTransformedPixels(clearing).forEach(coord=>{this._renderPixel(coord.x,coord.y,coord.char)});else{blit(surface.buffer,this.buffer,surface.width,surface.height,surface.T.b0,surface.T.b1);for(let x=surface.T.b0;x<surface.T.b0+surface.width;x+=this.TILESIZE)for(let y=surface.T.b1;y<surface.T.b1+surface.height;y+=this.TILESIZE)x<0||x>=this.pixelWidth||y<0||y>=this.pixelHeight||this.markDirty(this._coordToTile(x,y))}}_getBufferIndex(x,y){return x+y*(this.screenTileWidth*this.TILESIZE)}_getLegendIndex(tx,ty){return tx+ty*this.screenTileWidth}_coordToTile(x,y){return{tx:x>>4,ty:y>>4}}_renderPixel(x,y,char){this.buffer.setChar(x,y,char),this.markDirty(this._coordToTile(x,y))}_tileToBitmapKey(tx,ty){return String.fromCharCode(47+ty*this.screenTileWidth+tx)}_legendIndexToTile(index){const w=this.screenTileWidth;return{tx:index%w,ty:index/w|0}}_tileToBitmap(tx,ty){let bitmapRows=new Array(this.TILESIZE);const startX=tx*this.TILESIZE,startY=ty*this.TILESIZE;for(let y=0;y<this.TILESIZE;y++){let row=new Array(this.TILESIZE);for(let x=0;x<this.TILESIZE;x++)row[x]=this.buffer.getChar(startX+x,startY+y);bitmapRows[y]=row.join("")}return bitmapRows.join("\n")}_createTileBitmap(){let rows=new Array(this.screenTileHeight);for(let ty=0;ty<this.screenTileHeight;ty++){let row=new Array(this.screenTileWidth);for(let tx=0;tx<this.screenTileWidth;tx++)row[tx]=this._tileToBitmapKey(tx,ty);rows[ty]=row.join("")}return rows.join("\n")}_createLegend(){const legend=new Array(this.screenTileHeight*this.screenTileWidth),emptyBitmap=(".".repeat(16)+"\n").repeat(16);for(let ty=0;ty<this.screenTileHeight;ty++)for(let tx=0;tx<this.screenTileWidth;tx++){const bitmapKey=this._tileToBitmapKey(tx,ty);legend[this._getLegendIndex(tx,ty)]=[bitmapKey,emptyBitmap]}return legend}_bindDrawerMethods(){for(const key of Object.getOwnPropertyNames(Drawer.prototype))if("constructor"!==key&&"_"!==key[0]&&"function"==typeof this.drawer[key]){const drawFn=this.drawer[key].bind(this.drawer);this[key]=(...args)=>drawFn(...args)}}}class Surface{constructor(width,height){this.width=width,this.height=height,this.T=new Transform2D(1,0,0,1,0,0),this.buffer=new Buffer(this.width,this.height),this.drawer=new Drawer(this.buffer),this._bindDrawerMethods()}applyTransformation(T){this.T=this.T.multiply(T)}resetTransformations(){this.T=new Transform2D(1,0,0,1,0,0)}rotate(radians){const cosRad=Math.cos(radians),sinRad=Math.sin(radians);this.applyTransformation(new Transform2D(cosRad,-sinRad,sinRad,cosRad,0,0))}shear(shearX=0,shearY=0){this.applyTransformation(new Transform2D(1,shearX,shearY,1,0,0))}scale(scaleX=1,scaleY=1){this.applyTransformation(new Transform2D(scaleX,0,0,scaleY,0,0))}offset(offsetX=0,offsetY=0){this.applyTransformation(new Transform2D(1,0,0,1,offsetX,offsetY))}isTransformed(){return 1!==this.T.T00||1!==this.T.T11||0!==this.T.T01||0!==this.T.T10}getTransformedPixels(clearing=!1){const charFilter=char=>"."!==char;let transformedCoordinates=[];for(let y=0;y<this.height;y++)for(let x=0;x<this.width;x++){let char=this.buffer.getChar(x,y);(clearing||charFilter(char))&&transformedCoordinates.push({x:Math.floor(this.T.transformX(x,y)),y:Math.floor(this.T.transformY(x,y)),char:char})}return transformedCoordinates}_bindDrawerMethods(){for(const key of Object.getOwnPropertyNames(Drawer.prototype))if("constructor"!==key&&"_"!==key[0]&&"function"==typeof this.drawer[key]){const drawFn=this.drawer[key].bind(this.drawer);this[key]=(...args)=>drawFn(...args)}}}class Buffer{constructor(width,height){this.width=width,this.height=height,this.pixels=new PackedArray(this.width*this.height)}setChar(x,y,char){this.isInBounds(x,y)&&this.pixels.setChar(this.getBufferIndex(x,y),char)}getChar(x,y){return this.isInBounds(x,y)?this.pixels.getChar(this.getBufferIndex(x,y)):"."}clear(){this.pixels.resetValues()}isInBounds(x,y){return y<this.height&&y>=0&&x<this.width&&x>=0}getBufferIndex(x,y){return x+y*this.width}}class Drawer{constructor(buffer){this.buffer=buffer,this.width=this.buffer.width,this.height=this.buffer.height}drawPixel(x,y,char){x|=0,y|=0,this.buffer.isInBounds(x,y)&&this.buffer.setChar(x,y,char)}drawRect(x,y,rectWidth,rectHeight,char){if(x|=0,y|=0,!this.buffer.isInBounds(x,y))return;const xEnd=Math.min(this.width,x+rectWidth),yEnd=Math.min(this.height,y+rectHeight);for(let yi=y;yi<yEnd;yi++)for(let xi=x;xi<xEnd;xi++)this.buffer.setChar(xi,yi,char)}drawCircle(cx,cy,radius,char){cx|=0,cy|=0;const radiusSq=(radius=Math.max(1,0|radius))*radius,xStart=Math.max(0,cx-radius),yStart=Math.max(0,cy-radius),xEnd=Math.min(this.width,cx+radius+1),yEnd=Math.min(this.height,cy+radius+1);for(let y=yStart;y<yEnd;y++)for(let x=xStart;x<xEnd;x++){const dx=x-cx,dy=y-cy;dx*dx+dy*dy<=radiusSq&&this.buffer.setChar(x,y,char)}}clearRect(x,y,width,height){this.drawRect(x,y,width,height,".")}clearSurface(){this.buffer.clear()}drawLine(x0,y0,x1,y1,char){x0|=0,y0|=0,x1|=0,y1|=0;let dx=Math.abs(x1-x0),dy=Math.abs(y1-y0),sx=x0<x1?1:-1,sy=y0<y1?1:-1,err=dx-dy;for(;this.buffer.setChar(x0,y0,char),x0!==x1||y0!==y1;){let e2=2*err;e2>-dy&&(err-=dy,x0+=sx),e2<dx&&(err+=dx,y0+=sy)}}drawSprite(x,y,sprite){const xEnd=Math.min(sprite.width+x,this.width),yEnd=Math.min(sprite.height+y,this.height);for(let yi=y;yi<yEnd;yi++)for(let xi=x;xi<xEnd;xi++){let indexSprite=xi-x+(yi-y)*sprite.width;this.buffer.setChar(xi,yi,sprite.cArray.getChar(indexSprite))}}}class PackedArray{constructor(size){this.size=size,this.charToNibble={".":0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,L:10,C:11,D:12,F:13,H:14,0:15},this.nibbleToChar=Object.fromEntries(Object.entries(this.charToNibble).map(([k,v])=>[v,k])),this.values=new Uint8Array(this.size/2)}resetValues(){this.values=new Uint8Array(this.size/2)}getByteIndex(index){return index>>1}getValue(index){const byteIndex=this.getByteIndex(index),shift=1&index?0:4;return this.values[byteIndex]>>shift&15}setValue(index,val){const byteIndex=this.getByteIndex(index),shift=1&index?0:4,mask=1&index?240:15;this.values[byteIndex]=this.values[byteIndex]&mask|(15&val)<<shift}getChar(index){return this.nibbleToChar[this.getValue(index)]}setChar(index,char){this.setValue(index,this.charToNibble[char])}}class Transform2D{constructor(T00,T01,T10,T11,b0,b1){this.T00=T00,this.T01=T01,this.b0=b0,this.T10=T10,this.T11=T11,this.b1=b1}multiply(other){const T00=this.T00*other.T00+this.T01*other.T10,T01=this.T00*other.T01+this.T01*other.T11,b0=this.T00*other.b0+this.T01*other.b1+this.b0,T10=this.T10*other.T00+this.T11*other.T10,T11=this.T10*other.T01+this.T11*other.T11,b1=this.T10*other.b0+this.T11*other.b1+this.b1;return new Transform2D(T00,T01,T10,T11,b0,b1)}transformX(x,y){return this.T00*x+this.T01*y+this.b0}transformY(x,y){return this.T10*x+this.T11*y+this.b1}determinant(){return this.T00*this.T11-this.T01*this.T10}isInvertible(eps=1e-8){const det=this.determinant();return isFinite(det)&&Math.abs(det)>eps}inverse(){const det=this.determinant();if(!isFinite(det)||Math.abs(det)<1e-8)return null;const iT00=this.T11/det,iT01=-this.T01/det,iT10=-this.T10/det,iT11=this.T00/det,ib0=-(iT00*this.b0+iT01*this.b1),ib1=-(iT10*this.b0+iT11*this.b1);return new Transform2D(iT00,iT01,iT10,iT11,ib0,ib1)}}class Metrics{static testEfficiency(fn,...args){const start=performance.now();fn(...args);const end=performance.now();console.log(`Execution time: ${(end-start).toFixed(4)} ms`)}static testMethodEfficiency(obj,methodName,...args){let sum=0;for(let i=0;i<100;i++){const start=performance.now();obj[methodName](...args);sum+=performance.now()-start}console.log(`${methodName} executed in ${(sum/100).toFixed(4)} ms`)}static toMB(byteLength){return byteLength/1048576}static logHeapUsage(){console.log(Metrics.toMB(performance.memory.usedJSHeapSize).toFixed(2),"MB")}}function blit(sourceBuffer,destBuffer,copyWidth,copyHeight,x=0,y=0){const srcStride=sourceBuffer.width,destStride=destBuffer.width,destWidth=destBuffer.width,destHeight=destBuffer.height;let sx=0,sy=0;if(x<0&&(sx=-x,copyWidth+=x,x=0),y<0&&(sy=-y,copyHeight+=y,y=0),x+copyWidth>destWidth&&(copyWidth=destWidth-x),y+copyHeight>destHeight&&(copyHeight=destHeight-y),copyWidth<=0||copyHeight<=0)return;const maxHeight=Math.min(copyHeight,destHeight-y);for(let row=0;row<maxHeight;row++){let curDestX=x,curSrcX=sx,remainingWidth=copyWidth;const destRowY=y+row,srcRowY=sy+row;if(!((1&curDestX)==(1&curSrcX))&&(curSrcX++,remainingWidth--,remainingWidth<=0))continue;if(1&curDestX){const destBufferIndex=getBufferIndex(curDestX,destRowY,destStride),sourceBufferIndex=getBufferIndex(curSrcX,srcRowY,srcStride);destBuffer.pixels.setValue(destBufferIndex,sourceBuffer.pixels.getValue(sourceBufferIndex)),curDestX++,curSrcX++,remainingWidth--}const fullBytes=remainingWidth>>1;if(fullBytes>0){const destBufferIndex=getBufferIndex(curDestX,destRowY,destStride),sourceBufferIndex=getBufferIndex(curSrcX,srcRowY,srcStride),dStart=destBuffer.pixels.getByteIndex(destBufferIndex),sStart=sourceBuffer.pixels.getByteIndex(sourceBufferIndex);destBuffer.pixels.values.set(sourceBuffer.pixels.values.subarray(sStart,sStart+fullBytes),dStart)}if(1&remainingWidth){const destLastIndex=curDestX+--remainingWidth,srcLastIndex=curSrcX+remainingWidth;destBuffer.pixels.setValue(destLastIndex,sourceBuffer.pixels.getValue(srcLastIndex))}}}function getBufferIndex(x,y,width){return x+y*width}class Sprite{constructor(byteArray,width,height,bitDepth=8){this.width=width,this.height=height,this.bitDepth=bitDepth,this.data=byteArray}fromBase64RGBA(base64,width,height,inputBitDepth=8){const bin=atob(base64),rgbaBytes=new Uint8Array(bin.length);for(let i=0;i<bin.length;i++)rgbaBytes[i]=this._normaliseChannel(bin.charCodeAt(i));let paletteBytes=new Uint8Array(Math.floor(bin.length/4));return rgbaBytes.reduce((paletteIndex,cur,i,src)=>{if(i%4==0&&i+3<src.length){const chunk=src.slice(i,i+4),val=this._rgbaToPalette(chunk);return paletteBytes[paletteIndex]=val,paletteIndex+1}return paletteIndex},0),new Sprite(paletteBytes,width,height,inputBitDepth)}getBitmap(){return this.data.reduce((acc,val,i)=>{let char=acc+charMap[val];return(i+1)%this.width===0&&(char+="\n"),char},"")}static rgbaToChar(rgbaValues){const mappedVal=Sprite._rgbaToPalette(rgbaValues);return charMap[mappedVal]}static _rgbaToPalette(rgbaValues){let mappedVal,minDif=5;const alpha=rgbaValues[3],rgbValues=rgbaValues.slice(0,3);if(alpha>=.5)return 15;for(const[paletteVal,charRgb]of Object.entries(colorMap)){const sumDif=rgbValues.reduce((sumDif,val,index)=>sumDif+Math.abs(charRgb[index]-val),0);sumDif<minDif&&(mappedVal=paletteVal,minDif=sumDif)}return mappedVal}_normaliseChannel(channelVal){return Math.round(channelVal/2**this.bitDepth)}}const colorMap={0:[0,0,0],1:[.282,.314,.337],2:[.569,.592,.608],3:[.973,.976,.98],4:[.922,.286,.392],5:[.545,.251,.184],6:[.102,.694,.976],7:[.071,.078,.878],8:[.996,.906,.059],9:[.58,.549,.2],10:[.176,.878,.243],11:[.11,.584,.059],12:[.957,.424,.733],13:[.667,.227,.773],14:[.957,.439,.09]},CHARS="0L123C756F4D8H9.",charMap=Object.fromEntries([...CHARS].map((ch,i)=>[i,ch]));