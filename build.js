// To use SubTile, copy the minified code below into your Sprig file.
// Refer to https://github.com/hatanuk/SubTile for usage details 
 
class SubTileRenderer{constructor(screenTileWidth=10,screenTileHeight=8){this.TILESIZE=16,this.screenTileHeight=screenTileHeight,this.screenTileWidth=screenTileWidth,this.pixelHeight=this.screenTileHeight*this.TILESIZE,this.pixelWidth=this.screenTileWidth*this.TILESIZE,this.dirtyBucket=new Set,this.surfaces=[],this.buffer=new Buffer(this.screenTileWidth*this.TILESIZE,this.screenTileHeight*this.TILESIZE),this.tileBitmap=this._createTileBitmap(),this.legend=this._createLegend(),setLegend(...this.legend),setMap(this.tileBitmap)}beginFrame(){this.clearDirtyBucket()}endFrame(){this.surfaces.forEach(surface=>{surface.isTransformed()?surface.getTransformedPixels().forEach(coord=>{this._renderPixel(coord.x,coord.y,coord.char)}):blit(surface.buffer,this.buffer,surface.width,surface.height,this.pixelWidth,this.pixelHeight,surface.T.b0,surface.T.b1);for(let x=surface.T.b0;x<surface.T.b0+surface.width;x+=this.TILESIZE)for(let y=surface.T.b1;y<surface.T.b1+surface.height;y+=this.TILESIZE)this.markDirty(this._coordToTile(x,y))});for(const index of this.dirtyBucket){const{tx:tx,ty:ty}=this._legendIndexToTile(index);this.legend[index][1]=this._tileToBitmap(tx,ty)}setLegend(...this.legend)}markDirty({tx:tx,ty:ty}){this.dirtyBucket.add(this._getLegendIndex(tx,ty))}clearDirtyBucket(){this.dirtyBucket.clear()}isDirty({tx:tx,ty:ty}){return this.dirtyBucket.has(this._getLegendIndex(tx,ty))}addSurface(surface,x=0,y=0){surface.T.b0=x,surface.T.b1=y,this.surfaces.includes(surface)?(this.removeSurface(surface),this.addSurface(surface,x,y)):this.surfaces.push(surface)}removeSurface(surface){this.surfaces=this.surfaces.filter(currentSurface=>currentSurface!==surface)}applyTransformation(surface,{scaleX:scaleX=1,scaleY:scaleY=1,xOffset:xOffset,yOffset:yOffset}={}){xOffset=xOffset??surface.T.b0,yOffset=yOffset??surface.T.b1,surface.applyTransformation(new Transform2D(scaleX,0,0,scaleY,xOffset,yOffset))}removeTransformation(surface){surface.removeTransformation()}_getBufferIndex(x,y){return x+y*(this.screenTileWidth*this.TILESIZE)}_getLegendIndex(tx,ty){return tx+ty*this.screenTileWidth}_coordToTile(x,y){return{tx:x>>4,ty:y>>4}}_renderPixel(x,y,char){this.buffer.setChar(x,y,char),this.markDirty(this._coordToTile(x,y))}_tileToBitmapKey(tx,ty){return String.fromCharCode(47+10*ty+tx)}_legendIndexToTile(index){const w=this.screenTileWidth;return{tx:index%w,ty:index/w|0}}_tileToBitmap(tx,ty){let bitmapRows=new Array(this.TILESIZE);const startX=tx*this.TILESIZE,startY=ty*this.TILESIZE;for(let y=0;y<this.TILESIZE;y++){let row=new Array(this.TILESIZE);for(let x=0;x<this.TILESIZE;x++)row[x]=this.buffer.getChar(startX+x,startY+y);bitmapRows[y]=row.join("")}return bitmapRows.join("\n")}_createTileBitmap(){let rows=new Array(this.screenTileHeight);for(let ty=0;ty<this.screenTileHeight;ty++){let row=new Array(this.screenTileWidth);for(let tx=0;tx<this.screenTileWidth;tx++)row[tx]=this._tileToBitmapKey(tx,ty);rows[ty]=row.join("")}return rows.join("\n")}_createLegend(){const legend=new Array(this.screenTileHeight*this.screenTileWidth),emptyBitmap=(".".repeat(16)+"\n").repeat(16);for(let ty=0;ty<this.screenTileHeight;ty++)for(let tx=0;tx<this.screenTileWidth;tx++){const bitmapKey=this._tileToBitmapKey(tx,ty);legend[this._getLegendIndex(tx,ty)]=[bitmapKey,emptyBitmap]}return legend}_bindDrawerMethods(){for(const key of Object.getOwnPropertyNames(Drawer.prototype))if("constructor"!==key&&"_"!==key[0]&&"function"==typeof this.drawer[key]){const drawFn=this.drawer[key].bind(this.drawer);this[key]=(...args)=>drawFn(...args)}}}class Surface{constructor(width,height){this.width=width,this.height=height,this.T=new Transform2D(1,0,0,1,0,0),this.buffer=new Buffer(this.width,this.height),this.drawer=new Drawer(this.buffer),this._bindDrawerMethods()}applyTransformation(T){this.T=this.T.multiply(T)}removeTransformation(){this.T=new Transform2D(1,0,0,1,0,0)}isTransformed(){return 1!==this.T.T00||1!==this.T.T11||0!==this.T.T01||0!==this.T.T01}getTransformedPixels(){const charFilter=char=>"."!==char;let transformedCoordinates=[];for(let y=0;y<this.height;y++)for(let x=0;x<this.width;x++){let char=this.buffer.getChar(x,y);charFilter(char)&&transformedCoordinates.push({x:Math.floor(this.T.transformX(x,y)),y:Math.floor(this.T.transformY(x,y)),char:char})}return transformedCoordinates}_bindDrawerMethods(){for(const key of Object.getOwnPropertyNames(Drawer.prototype))if("constructor"!==key&&"_"!==key[0]&&"function"==typeof this.drawer[key]){const drawFn=this.drawer[key].bind(this.drawer);this[key]=(...args)=>drawFn(...args)}}}class Buffer{constructor(width,height){this.width=width,this.height=height,this.pixels=new PackedArray(this.width*this.height)}setChar(x,y,char){this.isInBounds(x,y)&&this.pixels.setChar(this.getBufferIndex(x,y),char)}getChar(x,y){return this.isInBounds(x,y)?this.pixels.getChar(this.getBufferIndex(x,y)):"."}clear(){this.pixels.resetValues()}isInBounds(x,y){return y<this.height&&y>=0&&x<this.width&&x>=0}getBufferIndex(x,y){return x+y*this.width}}class Drawer{constructor(buffer){this.buffer=buffer,this.width=this.buffer.width,this.height=this.buffer.height}drawPixel(x,y,char){x|=0,y|=0,this.buffer.isInBounds(x,y)&&this.buffer.setChar(x,y,char)}drawRect(x,y,rectWidth,rectHeight,char){if(x|=0,y|=0,!this.buffer.isInBounds(x,y))return;const xEnd=Math.min(this.width,x+rectWidth),yEnd=Math.min(this.height,y+rectHeight);for(let yi=y;yi<yEnd;yi++)for(let xi=x;xi<xEnd;xi++)this.buffer.setChar(xi,yi,char)}drawCircle(cx,cy,radius,char){cx|=0,cy|=0;const radiusSq=(radius=Math.max(1,0|radius))*radius,xStart=Math.max(0,cx-radius),yStart=Math.max(0,cy-radius),xEnd=Math.min(this.width,cx+radius+1),yEnd=Math.min(this.height,cy+radius+1);for(let y=yStart;y<yEnd;y++)for(let x=xStart;x<xEnd;x++){const dx=x-cx,dy=y-cy;dx*dx+dy*dy<=radiusSq&&this.buffer.setChar(x,y,char)}}clearRect(x,y,width,height){this.drawRect(x,y,width,height,".")}clearCanvas(){this.buffer.clear()}drawLine(x0,y0,x1,y1,char){x0|=0,y0|=0,x1|=0,y1|=0;let dx=Math.abs(x1-x0),dy=Math.abs(y1-y0),sx=x0<x1?1:-1,sy=y0<y1?1:-1,err=dx-dy;for(;this.buffer.setChar(x0,y0,char),x0!==x1||y0!==y1;){let e2=2*err;e2>-dy&&(err-=dy,x0+=sx),e2<dx&&(err+=dx,y0+=sy)}}drawSprite(x,y,sprite){const xEnd=Math.min(sprite.width+x,this.width),yEnd=Math.min(sprite.height+y,this.height);for(let yi=y;yi<yEnd;yi++)for(let xi=x;xi<xEnd;xi++){let indexBuffer=this._getBufferIndex(xi,yi),indexSprite=xi-x+(yi-y)*sprite.width;this.buffer.setChar(indexBuffer,sprite.cArray.getChar(indexSprite))}}}class PackedArray{constructor(size){this.size=size,this.charToNibble={".":0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,L:10,C:11,D:12,F:13,H:14,0:15},this.nibbleToChar=Object.fromEntries(Object.entries(this.charToNibble).map(([k,v])=>[v,k])),this.values=new Uint8Array(this.size/2)}resetValues(){this.values=new Uint8Array(this.size/2)}getByteIndex(index){return index>>1}getValue(index){const byteIndex=this.getByteIndex(index),shift=1&index?0:4;return this.values[byteIndex]>>shift&15}setValue(index,val){const byteIndex=this.getByteIndex(index),shift=1&index?0:4,mask=1&index?240:15;this.values[byteIndex]=this.values[byteIndex]&mask|(15&val)<<shift}getChar(index){return this.nibbleToChar[this.getValue(index)]}setChar(index,char){this.setValue(index,this.charToNibble[char])}}class Transform2D{constructor(T00,T01,T10,T11,b0,b1){this.T00=T00,this.T01=T01,this.b0=b0,this.T10=T10,this.T11=T11,this.b1=b1}multiply(other){const T00=this.T00*other.T00+this.T01*other.T10,T01=this.T00*other.T01+this.T01*other.T11,b0=this.T00*other.b0+this.T01*other.b1+this.b0,T10=this.T10*other.T00+this.T11*other.T10,T11=this.T10*other.T01+this.T11*other.T11,b1=this.T10*other.b0+this.T11*other.b1+this.b1;return new Transform2D(T00,T01,T10,T11,b0,b1)}transformX(x,y){return this.T00*x+this.T01*y+this.b0}transformY(x,y){return this.T10*x+this.T11*y+this.b1}}class Metrics{testEfficiency(fn,...args){const start=performance.now();fn(...args);const end=performance.now();console.log(`Execution time: ${(end-start).toFixed(4)} ms`)}testMethodEfficiency(obj,methodName,...args){let sum=0;for(let i=0;i<30;i++){const start=performance.now();obj[methodName](...args);sum+=performance.now()-start}console.log(`${methodName} executed in ${(sum/30).toFixed(4)} ms`)}}function blit(sourceBuffer,destBuffer,sourceWidth,sourceHeight,destWidth,destHeight,x=0,y=0){const maxHeight=Math.min(sourceHeight,destHeight-y);for(let srcRowY=0;srcRowY<maxHeight;srcRowY++){let curDestX=x,curSrcX=0,remainingWidth=sourceWidth;const destRowY=y+srcRowY;if((1&curDestX)==(1&curSrcX)||(curDestX=Math.max(0,curDestX-1)),1&curDestX){const destBufferIndex=getBufferIndex(curDestX,destRowY,destWidth),sourceBufferIndex=getBufferIndex(curSrcX,srcRowY,sourceWidth);destBuffer.setValue(destBufferIndex,sourceBuffer.getValue(sourceBufferIndex)),curDestX++,curSrcX++,remainingWidth--}const fullBytes=remainingWidth>>1;if(fullBytes>0){const destBufferIndex=getBufferIndex(curDestX,destRowY,destWidth),sourceBufferIndex=getBufferIndex(curSrcX,srcRowY,sourceWidth),dStart=destBuffer.pixels.getByteIndex(destBufferIndex),sStart=sourceBuffer.pixels.getByteIndex(sourceBufferIndex);destBuffer.pixels.values.set(sourceBuffer.pixels.values.subarray(sStart,sStart+fullBytes),dStart)}if(1&remainingWidth){const destLastIndex=curDestX+--remainingWidth,srcLastIndex=curSrcX+remainingWidth;destBuffer.setValue(destLastIndex,sourceBuffer.getValue(srcLastIndex))}}}function getBufferIndex(x,y,width){return x+y*width}class Sprite{colorMap={0:[0,0,0],L:[72,80,86],1:[145,151,155],2:[248,249,250],3:[235,73,100],C:[139,64,47],7:[26,177,249],5:[18,20,224],6:[254,231,15],F:[148,140,51],4:[45,224,62],D:[28,149,15],8:[244,108,187],H:[170,58,197],9:[244,112,23]};constructor(rgbArray,width,height){this.width=width,this.height=height,this.init(rgbArray,width,height)}init(rgbArray,width,height){let charArray=this.rgbArrayToCharArray(rgbArray,width,height);charArray.length%2!=0&&charArray.push("."),this.cArray=new PackedArray(charArray.length),charArray.forEach((char,index)=>this.cArray.setChar(index,char))}rgbArrayToCharArray(rgbArray,width,height){let charArray=[];for(let y=0;y<height;y++)for(let x=0;x<width;x++){const index=3*(x+y*width);let rgbValue=rgbArray.slice(index,index+3),mappedChar=this.rgbValueToChar(rgbValue);charArray.push(mappedChar)}return charArray}rgbValueToChar(rgbValue){let smallestDif=765,mappedChar=".";for(const[char,charRgb]of Object.entries(this.colorMap)){const sumDif=rgbValue.reduce((sumDif,val,index)=>sumDif+Math.abs(charRgb[index]-val),0);sumDif<smallestDif&&(mappedChar=char,smallestDif=sumDif)}return mappedChar}getBitmap(){let bitmap="";for(let y=0;y<this.height;y++){for(let x=0;x<this.width;x++){let index=y*this.width+x;bitmap+=this.cArray.getChar(index)}bitmap+="\n"}return bitmap}}